import * as algos from './algo';

// After adding the export in algos/index.js, add new algorithms in the following format:
// AlgorithmName: ['Menu Display Name', algos.ClassName, hasPseudoCode, 'Verbose Display Name (optional)']
export const algoMap = {
	NonLinearProbing: ['Non-Linear Probing', algos.NonLinearProbing],
	LVA: ['LVA', algos.LVA],
	BogoSort: ['Bogo Sort', algos.BogoSort],
	ArrayList: ['ArrayList', algos.ArrayList, true],
	LinkedList: ['Singly LinkedList', algos.LinkedList, true],
	DoublyLinkedList: ['Doubly LinkedList', algos.DoublyLinkedList, true],
	CircularlyLinkedList: ['Circularly LinkedList', algos.CircularlyLinkedList, true],
	StackArray: ['Stack (Array)', algos.StackArray, true],
	StackLL: ['Stack (LinkedList)', algos.StackLL, true],
	QueueArray: ['Queue (Array)', algos.QueueArray, true],
	QueueLL: ['Queue (LinkedList)', algos.QueueLL, true],
	DequeArray: ['Deque (Array)', algos.DequeArray, true],
	DequeLL: ['Deque (LinkedList)', algos.DequeLL],
	BST: ['Binary Search Tree', algos.BST, true],
	Heap: ['Heaps / PQs', algos.Heap],
	SkipList: ['SkipList', algos.SkipList],
	OpenHash: ['HashMap (Probing)', algos.OpenHash],
	ClosedHash: ['HashMap (Chaining)', algos.ClosedHash],
	SplayTree: ['SplayTree', algos.SplayTree],
	AVL: ['AVL', algos.AVL],
	BTree: ['2-4 Tree', algos.BTree],
	BubbleSort: ['Bubble Sort', algos.BubbleSort, true],
	CocktailSort: ['Cocktail Shaker Sort', algos.CocktailSort, true],
	InsertionSort: ['Insertion Sort', algos.InsertionSort, true],
	SelectionSort: ['Selection Sort', algos.SelectionSort, true],
	Quicksort: ['Quicksort', algos.Quicksort, true],
	Quickselect: ['Quick / kᵗʰ Select', algos.Quickselect, true],
	MergeSort: ['MergeSort', algos.MergeSort, true],
	LSDRadix: ['LSD Radix Sort', algos.LSDRadix, true],
	HeapSort: ['HeapSort', algos.HeapSort, true],
	BruteForce: ['Brute Force', algos.BruteForce, true],
	BoyerMoore: ['Boyer-Moore', algos.BoyerMoore, true],
	KMP: ['KMP', algos.KMP, true],
	RabinKarp: ['Rabin-Karp', algos.RabinKarp, true],
	BFS: ['Breadth-First Search', algos.BFS, true],
	DFS: ['Depth-First Search', algos.DFS, true],
	Dijkstra: ["Dijkstra's", algos.Dijkstras, true],
	Prim: ["Prim's", algos.Prims, true],
	Kruskal: ["Kruskal's", algos.Kruskals, true],
	LCS: ['LCS', algos.LCS, true, 'Longest Common Subsequence'],
	Floyd: ['Floyd-Warshall', algos.Floyd],
};

export const algoList = [
	'Lists',
	'ArrayList',
	'LinkedList',
	'DoublyLinkedList',
	'CircularlyLinkedList',
	'Stacks, Queues and Deques',
	'StackArray',
	'StackLL',
	'QueueArray',
	'QueueLL',
	'DequeArray',
	'DequeLL',
	'Trees and SkipList',
	'BST',
	'Heap',
	'AVL',
	// 'LVA',
	'BTree',
	'SplayTree',
	'SkipList',
	'HashMaps',
	'ClosedHash',
	'OpenHash',
	// 'NonLinearProbing',
	'Sorting and Quickselect',
	// 'BogoSort',
	'BubbleSort',
	'CocktailSort',
	'InsertionSort',
	'SelectionSort',
	'Quicksort',
	'Quickselect',
	'MergeSort',
	'LSDRadix',
	'HeapSort',
	'String Searching',
	'BruteForce',
	'BoyerMoore',
	'KMP',
	'RabinKarp',
	'Graph Algorithms',
	'BFS',
	'DFS',
	'Dijkstra',
	'Prim',
	'Kruskal',
	'Dynamic Programming',
	'LCS',
	'Floyd',
];

export const algoFilter = [
	{
		id: 'ArrayList',
		category: 'Lists',
	},
	{
		id: 'LinkedList',
		category: 'Lists',
	},
	{
		id: 'DoublyLinkedList',
		category: 'Lists',
	},
	{
		id: 'CircularlyLinkedList',
		category: 'Lists',
	},
	{
		id: 'StackArray',
		category: 'Linear Data Structures',
	},
	{
		id: 'StackLL',
		category: 'Linear Data Structures',
	},
	{
		id: 'QueueArray',
		category: 'Linear Data Structures',
	},
	{
		id: 'QueueLL',
		category: 'Linear Data Structures',
	},
	{
		id: 'DequeArray',
		category: 'Linear Data Structures',
	},
	{
		id: 'DequeLL',
		category: 'Linear Data Structures',
	},
	{
		id: 'BST',
		category: 'Trees',
	},
	{
		id: 'Heap',
		category: 'Trees',
	},
	{
		id: 'AVL',
		category: 'Trees',
	},
	{
		id: 'BTree',
		category: 'Trees',
	},
	{
		id: 'SplayTree',
		category: 'Trees',
	},
	{
		id: 'SkipList',
		category: 'SkipList',
	},
	{
		id: 'OpenHash',
		category: 'Hashmaps',
	},
	{
		id: 'ClosedHash',
		category: 'Hashmaps',
	},
	{
		id: 'BubbleSort',
		category: 'Sorting and Quick Select',
	},
	{
		id: 'CocktailSort',
		category: 'Sorting and Quick Select',
	},
	{
		id: 'InsertionSort',
		category: 'Sorting and Quick Select',
	},
	{
		id: 'QuickSort',
		category: 'Sorting and Quick Select',
	},
	{
		id: 'QuickSelect',
		category: 'Sorting and Quick Select',
	},
	{
		id: 'MergeSort',
		category: 'Sorting and Quick Select',
	},
	{
		id: 'LSDRadix',
		category: 'Sorting and Quick Select',
	},
	{
		id: 'HeapSort',
		category: 'Sorting and Quick Select',
	},
	{
		id: 'BruteForce',
		category: 'Pattern Matching',
	},
	{
		id: 'BoyerMoore',
		category: 'Pattern Matching',
	},
	{
		id: 'KMP',
		category: 'Pattern Matching',
	},
	{
		id: 'RabinKarp',
		category: 'Pattern Matching',
	},
	{
		id: 'BFS',
		category: 'Graph Algoritms',
	},
	{
		id: 'DFS',
		category: 'Graph Algoritms',
	},
	{
		id: 'Dijkstra',
		category: 'Graph Algoritms',
	},
	{
		id: 'Prim',
		category: 'Graph Algoritms',
	},
	{
		id: 'Krusal',
		category: 'Graph Algoritms',
	},
	{
		id: 'LCS',
		category: 'Dynamic Programming',
	},
	{
		id: 'Floyd',
		category: 'Dynamic Programming',
	},
];
